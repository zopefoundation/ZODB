<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>1.2 OODBs vs. Relational DBs</title>
<META NAME="description" CONTENT="1.2 OODBs vs. Relational DBs">
<META NAME="keywords" CONTENT="zodb">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<meta http-equiv="Content-Type" content="text/html; charset=">
<link rel="STYLESHEET" href="zodb.css">
<link rel="first" href="zodb.html">
<link rel="contents" href="contents.html" title="Contents">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node5.html">
</head>
<body>
<DIV CLASS="navigation">
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><A HREF="node3.html"><img src="/python/writing/icons/previous.gif"
  border="0" height="32"
  alt="Previous Page" width="32"></A></td>
<td><A HREF="node2.html"><img src="/python/writing/icons/up.gif"
  border="0" height="32"
  alt="Up One Level" width="32"></A></td>
<td><A HREF="node5.html"><img src="/python/writing/icons/next.gif"
  border="0" height="32"
  alt="Next Page" width="32"></A></td>
<td align="center" width="100%">ZODB/ZEO Programming Guide</td>
<td><A href="contents.html"><img src="/python/writing/icons/contents.gif"
  border="0" height="32"
  alt="Contents" width="32"></A></td>
<td><img src="/python/writing/icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
<td><img src="/python/writing/icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
</tr></table>
<b class="navlabel">Previous:</b> <a class="sectref" HREF="node3.html">1.1 What is the</A>
<b class="navlabel">Up:</b> <a class="sectref" HREF="node2.html">1 Introduction</A>
<b class="navlabel">Next:</b> <a class="sectref" HREF="node5.html">1.3 What is ZEO?</A>
<br><hr>
</DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION000220000000000000000">
1.2 OODBs vs. Relational DBs</A>
</H2>

<P>
Another way to look at it is that the ZODB is a Python-specific
object-oriented database (OODB).  Commercial object databases for C++
or Java often require that you jump through some hoops, such as using
a special preprocessor or avoiding certain data types.  As we'll see,
the ZODB has some hoops of its own to jump through, but in comparison
the naturalness of the ZODB is astonishing.

<P>
Relational databases (RDBs) are far more common than OODBs.
Relational databases store information in tables; a table consists of
any number of rows, each row containing several columns of
information.  (Rows are more formally called relations, which is where
the term ``relational database'' originates.)

<P>
Let's look at a concrete example.  The example comes from my day job
working for the MEMS Exchange, in a greatly simplified version.  The
job is to track process runs, which are lists of manufacturing steps
to be performed in a semiconductor fab.  A run is owned by a
particular user, and has a name and assigned ID number.  Runs consist
of a number of operations; an operation is a single step to be
performed, such as depositing something on a wafer or etching
something off it.

<P>
Operations may have parameters, which are additional information
required to perform an operation.  For example, if you're depositing
something on a wafer, you need to know two things: 1) what you're
depositing, and 2) how much should be deposited.  You might deposit
100 microns of silicon oxide, or 1 micron of copper.

<P>
Mapping these structures to a relational database is straightforward:

<P>
<dl><dd><pre class="verbatim">
CREATE TABLE runs (
  int      run_id,
  varchar  owner,
  varchar  title,
  int      acct_num,
  primary key(run_id)
);

CREATE TABLE operations (
  int      run_id,
  int      step_num, 
  varchar  process_id,
  PRIMARY KEY(run_id, step_num),
  FOREIGN KEY(run_id) REFERENCES runs(run_id),
);

CREATE TABLE parameters (
  int      run_id,
  int      step_num, 
  varchar  param_name, 
  varchar  param_value,
  PRIMARY KEY(run_id, step_num, param_name)
  FOREIGN KEY(run_id, step_num) 
     REFERENCES operations(run_id, step_num),
);
</pre></dl>

<P>
In Python, you would write three classes named <tt class="class">Run</tt>,
<tt class="class">Operation</tt>, and <tt class="class">Parameter</tt>.  I won't present code for
defining these classes, since that code is uninteresting at this
point. Each class would contain a single method to begin with, an
<tt class="method">__init__</tt> method that assigns default values, such as 0 or
<code>None</code>, to each attribute of the class.

<P>
It's not difficult to write Python code that will create a <tt class="class">Run</tt>
instance and populate it with the data from the relational tables;
with a little more effort, you can build a straightforward tool,
usually called an object-relational mapper, to do this automatically.
(See
<a class="url" href="http://www.amk.ca/python/unmaintained/ordb.html">http://www.amk.ca/python/unmaintained/ordb.html</a> for a quick hack
at a Python object-relational mapper, and
<a class="url" href="http://www.python.org/workshops/1997-10/proceedings/shprentz.html">http://www.python.org/workshops/1997-10/proceedings/shprentz.html</a>for Joel Shprentz's more successful implementation of the same idea;
Unlike mine, Shprentz's system has been used for actual work.)

<P>
However, it is difficult to make an object-relational mapper
reasonably quick; a simple-minded implementation like mine is quite
slow because it has to do several queries to access all of an object's
data.  Higher performance object-relational mappers cache objects to
improve performance, only performing SQL queries when they actually
need to.

<P>
That helps if you want to access run number 123 all of a sudden.  But
what if you want to find all runs where a step has a parameter named
'thickness' with a value of 2.0?  In the relational version, you have
two unappealing choices:

<P>

<OL>
<LI>Write a specialized SQL query for this case: <code>SELECT run_id
  FROM operations WHERE param_name = 'thickness' AND param_value = 2.0</code>

<P>
If such queries are common, you can end up with lots of specialized
  queries.  When the database tables get rearranged, all these queries
  will need to be modified.

<P>
</LI>
<LI>An object-relational mapper doesn't help much.  Scanning
  through the runs means that the the mapper will perform the required
  SQL queries to read run #1, and then a simple Python loop can check
  whether any of its steps have the parameter you're looking for.
  Repeat for run #2, 3, and so forth.  This does a vast
  number of SQL queries, and therefore is incredibly slow.

<P>
</LI>
</OL>

<P>
An object database such as ZODB simply stores internal pointers from
object to object, so reading in a single object is much faster than
doing a bunch of SQL queries and assembling the results. Scanning all
runs, therefore, is still inefficient, but not grossly inefficient.

<P>

<DIV CLASS="navigation">
<p><hr>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><A HREF="node3.html"><img src="/python/writing/icons/previous.gif"
  border="0" height="32"
  alt="Previous Page" width="32"></A></td>
<td><A HREF="node2.html"><img src="/python/writing/icons/up.gif"
  border="0" height="32"
  alt="Up One Level" width="32"></A></td>
<td><A HREF="node5.html"><img src="/python/writing/icons/next.gif"
  border="0" height="32"
  alt="Next Page" width="32"></A></td>
<td align="center" width="100%">ZODB/ZEO Programming Guide</td>
<td><A href="contents.html"><img src="/python/writing/icons/contents.gif"
  border="0" height="32"
  alt="Contents" width="32"></A></td>
<td><img src="/python/writing/icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
<td><img src="/python/writing/icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
</tr></table>
<b class="navlabel">Previous:</b> <a class="sectref" HREF="node3.html">1.1 What is the</A>
<b class="navlabel">Up:</b> <a class="sectref" HREF="node2.html">1 Introduction</A>
<b class="navlabel">Next:</b> <a class="sectref" HREF="node5.html">1.3 What is ZEO?</A>
<hr>
<span class="release-info">Release 0.03, documentation updated on February 8, 2002.</span>
</DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
